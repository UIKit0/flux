Flux Operating System 0.4a
User Manual Section 1 - ABI
==============================

Contents:
==============================
1 - Process Control
2 - Memory Management
3 - Interprocess Communication
4 - Driver Interfaces

1 - Process Control
==============================
Flux provides the same two basic system calls for process creation and 
destruction as UNIX: fork and exit. However, a few small differences exist.

fork: int 0x48
------------------------------
- takes no arguments
- returns either
	- 0 on failure
	- positive of child PID if parent
	- negative of parent PID if child
- creates a new process from the current one
	- same memory contents
	- same process flags
	- new PID and address space

exit: int 0x49
------------------------------
- takes one argument
	- ecx: exit value page
- does not return
- destroys current process
- sends signal to parent
	- sig 7: SSIG_DEATH
	- exit value page granted

There is also a system call that controls the state of the current process,
called pctl.

pctl: int 0x4A
------------------------------
- takes two arguments
	- eax: flag values
	- edx: flag mask
- returns current flag values
- sets flags marked in flag mask to values in flag values
- currently assigned flags
	- bit 0: 		CTRL_BLOCK: block scheduling
	- bit 1: 		CTRL_CLEAR: block signals (name? think x86 CLI)
	- bit 2: 		CTRL_ENTER: signal on reentry
	- bit 3: 		CTRL_SUPER: super (super only)
	- bit 4: 		CTRL_PORTS: port i/o (super only)
	- bit 5: 		CTRL_IRQRD: set irq redirect (super only)
	- bit 6:		unassigned
	- bit 7: 		CTRL_RNICE: change scheduling priority
	- bits 8-11: 	scheduling priority (bit 8 super only)
	- bits 12-23:	unassigned
	- bits 24-31: 	irq number (super only)

2 - Memory Management
==============================
All Flux memory management is done through a single mulitplexed call: mmap. 
Flux does not allow any memory to be mapped in multiple address spaces, for
stability and security reasons. However, this does not mean it cannot take
advantage of the paging system it requires: signals can grant pages to other 
processes with the help of this call.

mmap: int 0x50
------------------------------
- takes three arguments
	- ebx: virtual address
		- must be page aligned
	- ecx: page count
		- maximum 1024 pages per call
		- assumed to be 1 if MMAP_FRAME or MMAP_PHYS
	- edx: flags | frame
		- first 12 bits: flags
			- bit 0: MMAP_READ:  page is readable
			- bit 1: MMAP_WRITE: page is writable
			- bit 2: MMAP_EXEC:  page is executable
			- bit 3: MMAP_FREE:  free page instead of allocating
			- bit 4: MMAP_FRAME: try to use frame
			- bit 5: MMAP_PHYS:  return frame of page instead of allocating
			- bit 6: MMAP_MOVE:  move pages from address to address
		- last 20 bits: grant page (if MMAP_FRAME)
			- only allowed if super or if frame was granted
			- also used as source address for MMAP_MOVE
- returns 0 on success, negative on failure
- maps memory with the requested flags into the requested frames

3 - Interprocess Communication
==============================
Flux has only one basic IPC facility: signals. Signals can be described as a 
form of asynchronous message passing with event driven capabilities. Along
with general interprocess communication, signals are also used by the kernel 
to notify processes of internal exceptions, IRQ firings, and other events.
Signals are the only way to create threads other than the main thread that is
created when forking processes.

Four system calls are used to work with signals: fire, drop, sctl, and mail.

fire: int 0x40
------------------------------
- takes three arguments
	- eax: target process
	- ebx: granted page
	- ecx: signal number
		- limited to 16 bits
		- first 16 reserved for system
	- edx: flags
		- bit 0: FIRE_TAIL:	drop before firing
- returns 0 on success, negative on failure
- action depends on signal policy (see sctl)
	- policy is POLICY_ABORT
		- exit current process
	- policy is POLICY_EVENT
		- new thread is created in target process
		- esi set to calling PID
		- ebx set to granted page
		- edi set to signal number
		- instruction pointer set to signal handle
	- policy is POLICY_QUEUE or no signal handle
		- signal information added to signal queue
- grants page if non-null
- currently assigned signals:
	- 0: SSIG_FAULT:	general exception
	- 1: SSIG_ENTER:	reentry
	- 2: SSIG_PAGE:		page fault
	- 3: SSIG_IRQ:		registered IRQ
	- 4: SSIG_KILL:		kill signal
	- 5: SSIG_IMAGE:	image overflow
	- 6: SSIG_FLOAT:	floating point exception
	- 7: SSIG_DEATH:	child death
	- 16: SIG_READ:		driver read request
	- 17: SIG_WRITE:	driver write request
	- 18: SIG_INFO:		driver info request
	- 19: SIG_CTRL:		driver control request
	- 20: SIG_PING:		ping request
	- 32: SIG_REPLY:	generic reply

drop: int 0x41
------------------------------
- takes no arguments
- does not return
- if granted page has not been mapped, it is freed
- signal handling thread destroyed

sctl: int 0x42
------------------------------
- takes three arguments
	- eax: selector
	- ecx: signal
	- edx: value
- returns previous value at selector
- currently assigned selectors:
	- 0: signal policy
		- each signal can be set to three possible policies:
			- 0: POLICY_ABORT: exit process on reception
			- 1: POLICY_EVENT: call signal handle on reception
			- 2: POLICY_QUEUE: redirect to signal queue
	- 1: signal handle
		- address of signal handle function

mail: int 0x43
------------------------------
- takes three arguments
	- eax: operation
	- ecx: signal
	- edx: source search (if nonzero)
- if operation is 0
	- returns first signal of type signal with source equal to edx in queue
	- if edx is zero, returns first signal of type signal in queue
- if operation is nonzero
	- adds signal used to spawn current thread to queue
	- returns nothing

4 - Driver Interfaces
==============================
Drivers in Flux are individual processes, which have special privileges. Init
spawns a process called devd, the device daemon, which analyzes the hardware 
and spawns drivers. Drivers have the CTRL_SUPER flag set, which allows them to 
request port access and map frames directly, through the CTRL_PORTS and 
MMAP_FRAME flags. They can also request that a single IRQ be redirected as 
signal 1 to them. These things are managed though interfaces in libflux.

Drivers are launched during init by a service called the device daemon, or
devd. It detects all of the devices in the system automatically, and loads
the appropriate drivers. These drivers are provided with a device ID where they
should look for information. devd will also spawn drivers when devices are
hotplugged, and respawn them if they crash. Its behavior has not beed defined
yet.

In order to be used, drivers must be registered with the virtual filesystem
daemon, vfsd. vfsd is essentially a dictionary of resources managed by drivers
in the system, that provides those drivers' PIDs to requesting processes. Its
behavior has not been defined yet.

Drivers also have access to another service that lets them properly interface
with the rest of the system: the process metadata daemon, pmdd. pmdd keeps track
of all metadata about processes that is not basic mechanism information stored
by the kernel (PID, flags, signal handler). This includes process name, user, 
permissions, etc. Processes have the choice of registering, but will have little
or no resource access without doing so. Drivers may use pmdd along with libpermit 
to decide whether to allow access to a resource. Its behavior has not been defined
yet.

Drivers should implement a basic set of standard interfaces so processes can
use them in a consistent fashion:
- sig 16: read	(read data)
- sig 17: write	(write data)
- sig 18: info	(get metadata)
- sig 19: ctrl	(set metadata)
- sig 20: ping	(reply immediately)
- sig 32: reply	(a reply from a driver)

Resource 0 should represent the entire device.

Data is given to drivers through granted pages. These pages have a standard
header format that takes up the first 32 bytes, which will specify the exact
action that should be taken by the driver. Here is a draft of the format:
- bits 000-031: checksum		(bit parity dword)
- bits 032-063: resource ID		(resource ID == inode for block devices)
- bits 064-079: data size		(less than page size)
- bits 080-095: transaction ID	(defined by caller, used for reply)
- bits 096-111: internal offset	(from start of header)
- bits 112-127: header format	(0 = basic (this); others undefined)
- bits 128-255: file offset		(screw you if files are > 2^128 bytes)

When an action finishes, the driver should reply with a signal which has a 
granted page with a header containing the same transaction ID as was sent, 
using signal 32: SIG_REPLY.
