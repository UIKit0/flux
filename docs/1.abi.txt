Flux Operating System 0.2a
User Manual Section 1 - ABI
==============================

Contents:
==============================
1 - Process Control
2 - Memory Management
3 - Interprocess Communication
4 - Driver Interfaces
5 - Executable Loading

1 - Process Control
==============================
Flux provides the same two basic system calls for process creation and 
destruction as UNIX: fork and exit. However, a few small differences exist.

fork: int 0x66
------------------------------
- takes no arguments
- returns either
	- 0 on failure
	- positive of child PID if parent
	- negative of parent PID if child
- creates a new process from the current one
	- same memory contents
	- same process flags
	- new PID and address space

exit: int 0x67
------------------------------
- takes one argument
	- ecx: exit value page
- does not return
- destroys current process
- sends signal to parent
	- sig 7: SSIG_DEATH
	- exit value page granted

There are also three system calls used to control the state of the current
process. These calls are ctrl, hand, and info.

ctrl: int 0x63
------------------------------
- takes two arguments
	- eax: flag values
	- edx: flag mask
- returns current flag values
- sets flags marked in flag mask to values in flag values
- currently assigned flags
	- bit 0: 		CTRL_BLOCK: block scheduling
	- bit 1: 		CTRL_CLEAR: block signals (name? think x86 CLI)
	- bit 2: 		CTRL_ENTER: signal on reentry
	- bit 3: 		CTRL_SUPER: super (super only)
	- bit 4: 		CTRL_PORTS: port i/o (super only)
	- bit 5: 		CTRL_IRQRD: set irq redirect (super only)
	- bit 6: 		CTRL_FLOAT: use FPU/SSE extensions
	- bit 7: 		CTRL_RNICE: change scheduling priority
	- bits 8-11: 	scheduling priority (bit 8 super only)
	- bit 12: 		CTRL_CBLOCK: clear CTRL_BLOCK when catching signal
	- bit 13:		CTRL_CCLEAR: set CTRL_CLEAR when catching signal
	- bits 14-15:	unassigned
	- bit 16:		CTRL_DBLOCK: clear CTRL_BLOCK when dropping
	- bit 17:		CTRL_DCLEAR: set CTRL_CLEAR when dropping
	- bits 18-19:	unassigned
	- bit 20:		CTRL_ASYNC: signals run as separate threads
	- bit 21:		CTRL_MULTI: enable multiple processors
	- bit 22:		CTRL_QUEUE: queue signals if possible in kernel
	- bit 23:		CTRL_MMCLR:	clear mapped pages (super only)
	- bits 24-31: 	irq number (super only)

hand: int 0x62
------------------------------
- takes one argument
	- eax: new handler
- returns previous handler
- sets signal hander for current process

info: int 0x64
------------------------------
- takes one argument
	- eax: selector
- returns requested data
- assigned selectors
	- 0: 	INFO_CPID:	current PID
	- 1: 	INFO_PPID:	parent PID
	- 2: 	INFO_TICK:	ticks elapsed
	- 3: 	INFO_ABIV:	kernel abi version
	- 4: 	INFO_USER:	highest user address
	- 5: 	INFO_CTRL:	enabled ctrl flags
	- 6: 	INFO_MMAP:	enabled mmap flags
	- 7: 	INFO_ARCH:	architecture ID
		- 0: 	unknown
		- 1: 	x86-32
		- 2: 	x86-64
	- 8: 	INFO_PAGE:	page size
	- 9: 	INFO_CPUN:	number of logical CPUs
	- 10:	INFO_LOAD:	system load

2 - Memory Management
==============================
All Flux memory management is done through a single mulitplexed call: mmap. 
Flux does not allow any memory to be mapped in multiple address spaces, for
stability and security reasons. However, this does not mean it cannot take
advantage of the paging system it requires: signals can grant pages to other 
processes with the help of this call.

mmap: int 0x65
------------------------------
- takes three arguments
	- ebx: virtual address
		- must be page aligned
	- ecx: page count
		- maximum 1024 pages per call
		- assumed to be 1 if MMAP_FRAME or MMAP_PHYS
	- edx: flags | frame
		- first 12 bits: flags
			- bit 0: MMAP_READ:  page is readable
			- bit 1: MMAP_WRITE: page is writable
			- bit 2: MMAP_EXEC:  page is executable
			- bit 3: MMAP_FREE:  free page instead of allocating
			- bit 4: MMAP_FRAME: try to use frame
			- bit 5: MMAP_PHYS:  return frame of allocated page
			- bit 6: MMAP_MOVE:  move pages from address to address
		- last 20 bits: grant page (if MMAP_FRAME)
			- only allowed if super or if frame was granted
			- also used as source address for MMAP_MOVE
- returns 0 on success, negative on failure
- maps memory with the requested flags into the requested frames

3 - Interprocess Communication
==============================
Flux has only one basic IPC facility: signals. Signals can be described as a 
form of asynchronous unqueued pure message passing, with an interface similar
to UNIX signals, which create a preemptive handler context in the target 
process. Signals are also used by the kernel to notify processes of internal
exceptions, IRQ firings, and other events. Signals can also be compared closely
to interrupts.

Two system calls are needed to work with signals: fire and drop.

fire: int 0x60
------------------------------
- takes three arguments
	- eax: target process
	- ebx: granted page
	- ecx: signal number
		- limited to 16 bits
		- first 16 reserved for system
	- edx: flags
		- bit 0: FIRE_TAIL:	drop before firing
- returns 0 on success, negative on failure
- fires a signal to another process
	- signal is created in new signal handling context
	- esi set to calling PID
	- ebx set to granted page
	- edi set to signal number
	- ebp set to previous context image address (read-only)
- grants page if non-null
- currently assigned signals:
	- 0: SSIG_FAULT:	general exception
	- 1: SSIG_ENTER:	reentry
	- 2: SSIG_PAGE:		page fault
	- 3: SSIG_IRQ:		registered IRQ
	- 4: SSIG_KILL:		kill signal
	- 5: SSIG_IMAGE:	image overflow
	- 6: SSIG_FLOAT:	floating point exception
	- 7: SSIG_DEATH:	child death
	- 16: SIG_READ:		driver read request
	- 17: SIG_WRITE:	driver write request
	- 18: SIG_INFO:		driver info request
	- 19: SIG_CTRL:		driver control request
	- 20: SIG_PING:		ping request
	- 32: SIG_REPLY:	generic reply

drop: int 0x61
------------------------------
- takes no arguments
- does not return
- if granted page is unmapped, it is freed
- signal handling context destroyed
- preempted context resumed immediately

4 - Driver Interfaces
==============================
Drivers in Flux are individual processes, which have special privileges. Init
spawns a process called devd, the device daemon, which analyzes the hardware 
and spawns drivers. Drivers have the CTRL_SUPER flag set, which allows them to 
request port access and map frames directly, through the CTRL_PORTS and 
MMAP_FRAME flags. They can also request that a single IRQ be redirected as 
signal 1 to them. These things are managed though interfaces in libdriver.

Drivers are launched during init by a service called the device daemon, or
devd. It detects all of the devices in the system automatically, and loads
the appropriate drivers. These drivers are provided with a device ID where they
should look for information. devd will also spawn drivers when devices are
hotplugged, and respawn them if they crash. Its behavior has not beed defined
yet.

In order to be used, drivers must be registered with the virtual filesystem
daemon, vfsd. vfsd is essentially a dictionary of resources managed by drivers
in the system, that provides those drivers' PIDs to requesting processes. Its
behavior has not been defined yet.

Drivers also have access to another service that lets them properly interface
with the rest of the system: the process metadata daemon, pmdd. pmdd keeps track
of all metadata about processes that is not basic mechanism information stored
by the kernel (PID, flags, signal handler). This includes process name, user, 
permissions, etc. Processes have the choice of registering, but will have little
or no resource access without doing so. Drivers may use pmdd along with libpermit 
to decide whether to allow access to a resource. Its behavior has not been defined
yet.

Drivers should implement a basic set of standard interfaces so processes can
use them in a consistent fashion:
- sig 16: read	(read data)
- sig 17: write	(write data)
- sig 18: info	(get metadata)
- sig 19: ctrl	(set metadata)
- sig 20: ping	(reply immediately)
- sig 32: reply	(a reply from a driver)

Resource 0 should represent the entire device.

Data is given to drivers through granted pages. These pages have a standard
header format that takes up the first 32 bytes, which will specify the exact
action that should be taken by the driver. Here is a draft of the format:
- bits 000-031: checksum		(bit parity dword)
- bits 032-063: resource ID		(resource ID == inode for block devices)
- bits 064-079: data size		(less than page size)
- bits 080-095: transaction ID	(defined by caller, used for reply)
- bits 096-111: internal offset	(from start of header)
- bits 112-127: header format	(0 = basic (this); others undefined)
- bits 128-255: file offset		(screw you if files are > 2^128 bytes)

When an action finishes, the driver should reply with a signal which has a 
granted page with a header containing the same transaction ID as was sent, 
using signal 32: SIG_REPLY.

5 - Executable Loading
==============================
The Flux kernel is clearly lacking in an exec system call. It also does not 
have adequate facilities for drivers to load executables for processes. So, all
executables are loaded directly by the calling process, with help from a 
library. Linking with different of these libraries, or "libexec"s, enables 
loading of different executable formats. The native format for Flux binaries 
is ELF, described in the UNIX System V ABI documentataion, but a programmer may
use any format he or she wishes. Execution is managed through interfaces in 
libexec. A standard libexec is part of the libc.
