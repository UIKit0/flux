Khaos Operating System 0.2
User Manual Section I - ABI
==============================

Contents:
==============================
I	- Process Control
II	- Memory Management
III	- Interprocess Communication
IV	- Driver Interfaces
V	- Executable Loading

I	- Process Control
==============================
Khaos provides the same two basic system calls for process creation and 
destruction as UNIX: fork and exit. However, a few small differences exist.

fork: int 0x66
------------------------------
- takes no arguments
- returns either
	- 0 on failure
	- positive of child PID if parent
	- negative of parent PID if child
- creates a new process from the current one
	- same memory contents
	- same process flags
	- new PID

exit: int 0x67
------------------------------
- takes one argument
	- ecx: exit value page
- does not return
- destroys current process
- sends signal to parent
	- sig 7: SSIG_DEATH
	- exit value page granted

There are also three system calls used to control the state of the current
process. These calls are ctrl, hand, and info.

ctrl: int 0x63
------------------------------
- takes two arguments
	- eax: flag values
	- edx: flag mask
- returns current flag values
- sets flags marked in flag mask to values in flag values
- currently assigned flags
	- bit 0: CTRL_SCHED: block scheduling
	- bit 1: CTRL_SIGNAL: block signals
	- bit 2: CTRL_ENTER: signal on reentry
	- bit 3: CTRL_SUPER: super (super only)
	- bit 4: CTRL_PORTS: port i/o (super only)
	- bit 5: CTRL_IRQRD: set irq redirect (super only)
	- bit 6: CTRL_FLOAT: use FPU/SSE extensions
	- bit 7: CTRL_RENICE: change scheduling priority
	- bits 8-11: scheduling priority (bit 8 super only)
	- bits 12-23: unassigned
	- bits 24-31: irq number (super only)

hand: int 0x62
------------------------------
- takes one argument
	- eax: new handler
- returns previous handler
- sets signal hander for current process

info: int 0x64
------------------------------
- takes one argument
	- eax: selector
- returns requested data
- assigned selectors
	- 0: current PID
	- 1: parent PID
	- 2: ticks elapsed
	- 3: kernel version

II	- Memory Management
==============================
All Khaos memory management is done through a single mulitplexed call: mmap. 
Khaos does not allow any memory to be mapped in multiple address spaces, for
stability and security reasons. However, this does not mean it cannot take
advantage of the paging system it requires: signals can grant pages to other 
processes with the help of this call.

mmap: int 0x65
------------------------------
- takes three arguments
	- ebx: virtual address
		- must be page aligned
	- ecx: page count
		- maximum 1024 pages per call
		- assumed to be 1 if MMAP_FRAME
	- edx: flags | frame
		- first 12 bits: flags
			- bit 0: MMAP_READ: page is readable
			- bit 1: MMAP_WRITE: page is writable
			- bit 2: MMAP_EXEC: page is executable
			- bit 3: MMAP_FREE: free page instead of allocating
			- bit 4: MMAP_FRAME: try to use frame
			- bit 5: MMAP_PHYS: return physical address
		- last 20 bits: grant page (if MMAP_FRAME)
			- only allowed if super or if frame was granted
- returns 0 on success, negative on failure
- maps memory with the requested flags into the requested frames

III	- Interprocess Communication
==============================
Khaos has only one basic IPC facility: signals. Signals can be described as a 
form of asynchronous unqueued pure message passing, with an interface similar
to UNIX signals, which create a preemptive handler context in the target 
process. Signals are also used by the kernel to notify processes of internal
exceptions, IRQ firings, and other events. Signals can also be compared closely
to interrupts.

Two system calls are needed to work with signals: fire and drop.

fire: int 0x60
------------------------------
- takes three arguments
	- eax: target process
	- ebx: granted page
	- ecx: signal number
		- limited to 16 bits
		- first 16 reserved for system
- returns 0 on success, negative on failure
- fires a signal to another process
	- signal is created in new signal handling context
	- esi set to calling PID
	- ebx set to granted page
	- edi set to signal number
	- ebp set to previous context image address (read-only)
- grants page if non-null
- currently assigned signals:
	- 0: SSIG_FAULT: general exception
	- 1: SSIG_ENTER: reentry
	- 2: SSIG_PAGE: page fault
	- 3: SSIG_IRQ: registered IRQ
	- 4: SSIG_KILL: kill signal
	- 5: SSIG_IMAGE: image overflow
	- 6: SSIG_FLOAT: floating point exception
	- 7: SSIG_DEATH: child death
	- 16: SIG_READ: driver read request
	- 17: SIG_WRITE: driver write request
	- 18: SIG_INFO: driver info request
	- 19: SIG_CTRL: driver control request
	- 20: SIG_PING: ping request
	- 32: SIG_REPLY: generic reply

drop: int 0x61
------------------------------
- takes no arguments
- does not return
- if granted page is unmapped, it is freed
- signal handling context destroyed
- preempted context resumed immediately

IV	- Driver Interfaces
==============================
Drivers in Khaos are individual processes, which have special privileges. Init
spawns a process called devd, the device daemon, which analyzes the hardware 
and spawns drivers. Drivers have the CTRL_SUPER flag set, which allows them to 
request port access and map frames directly, through the CTRL_PORTS and 
MMAP_FRAME flags. They can also request that a single IRQ be redirected as 
signal 1 to them. These things are managed though interfaces in libdriver.

In order to be used, drivers must be registered with the virtual filesystem
daemon, vfsd. vfsd is essentially a dictionary of resources managed by drivers
in the system, that provides those drivers' PIDs to requesting processes. Its
behavior has not been defined yet.

Drivers should implement a basic set of standard interfaces so processes can
use them in a consistent fashion:
- sig 16: read	(read data)
- sig 17: write	(write data)
- sig 18: info	(get metadata)
- sig 19: ctrl	(set metadata)
- sig 20: ping	(reply immediately)
- sig 32: reply	(a reply from a driver)

Resource 0 should represent the entire device.

Data is given to drivers through granted pages. These pages have a standard
header format that takes up the first 32 bytes, which will specify the exact
action that should be taken by the driver. Here is a draft of the format:
- bits 000-031: resource ID		(resource ID == inode for block devices)
- bits 032-047: data size		(less than page size)
- bits 048-063: transaction ID	(defined by caller, used for reply)
- bits 064-095: checksum		(of everything but checksum, byte product)
- bits 096-111: internal offset	(from start of header)
- bits 112-127: header format	(0 = basic (this); others undefined)
- bits 128-255: offset			(screw you if files are > 2^128 bytes)
All numbers are in NETWORK BYTE ORDER! (big endian).

When an action finishes, the driver should reply with a signal which has a 
granted page with a header containing the same transaction ID as was sent, 
using signal 32: SIG_REPLY.

V	- Executable Loading
==============================
The Khaos kernel is clearly lacking in an exec system call. It also does not 
have adequate facilities for drivers to load executables for processes. So, all
executables are loaded directly by the calling process, with help from a 
library. Linking with different of these libraries, or "libexec"s, enables 
loading of different executable formats. The native format for Khaos binaries 
is ELF, described in the UNIX System V ABI documentataion, but a programmer may
use any format (s)he wishes. Execution is managed through interfaces in 
libexec.
