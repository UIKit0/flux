Aether Virtual Machine Specification

Memory
================
The Aether VM uses a simple and mostly flat memory model. It is able to 
do direct memory access to everything that normal machine code is. The 
various register pointers are freely modifiable as well. However, the 
hidden OP register determines the offsets automatically added to all 
registers when they are set. This gives a rudimentary segment-like 
relocation mechanism, controlled exclusively by real code. If OP is set
to 0, the memory is flat. All other memory management (i.e. paging) is 
done by the real machine.

The Stack
================
Being a stack based architecture, the Aether VM stack is very important. 
The stack grows downward, just like in the x86. The SP register is a 
pointer to the top of that stack, and the VP register is used to keep 
track of the current frame. The stack is put at an undefined position 
to start, but is guaranteed to have a reasonable amount of memory 
allocated below it.

Arithmetic
================
The Aether VM is always a two's complement, little endian architecture.
Arithmetic is at least emulated to be up to 64 bit. There is no explicit 
implementation of floating point arithmetic, but such a thing can be 
done with runtime extensions.

Interoperability
================
Functions and other real code segments can be called from within the 
Aether VM using the "ecl" instruction. The stack, because it is the same 
as the C  stack, is used for the called function. The return value is 
pushed back onto the stack after the function completes.
