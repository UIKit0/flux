/*
 * Copyright (C) 2009-2011 Nick Johnson <nickbjohnson4224 at gmail.com>
 * 
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdint.h>
#include <driver.h>

#include "vga.h"

struct vga_mode modev[] = {

	{ /* MODE_80x25xT */

		/* register file */
		0x67,
		{0x03, 0x00, 0x03, 0x00, 0x02},
		{0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 
		 0x00, 0x4F, 0x0D, 0x0E, 0x00, 0x00, 0x00, 0x50, 
		 0x9C, 0x0E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xA3, 
		 0xFF},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 
		 0xFF},
		{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 
		 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
		 0x0C, 0x00, 0x0F, 0x08, 0x00},
		 
		 /* palette */
		 get_color_rgbi,
		 set_color_rgbi,
		 
		 /* dimensions */
		 0x18000,
		 80,
		 25,
		 8,

		 /* functions */
		 NULL,
		 NULL,
		 NULL,
		 NULL
	},

	{ /* MODE_640x480x2 */

		/* register file */
		0xE3,
		{0x03, 0x01, 0x0F, 0x00, 0x06},
		{0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0x0B, 0x3E,
		 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		 0xEA, 0x0C, 0xDF, 0x28, 0x00, 0xE7, 0x04, 0xE3,
		 0xFF},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F,
		 0xFF},
		{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07,
		 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
		 0x01, 0x00, 0x0F, 0x00, 0x00},

		 /* palette */
		 get_color_mono,
		 set_color_mono,
		 
		 /* dimensions */
		 0,
		 640,
		 480,
		 1,

		 /* functions */
		 NULL,
		 NULL,
		 NULL,
		 NULL
	},

	{ /* MODE_640x480x16 */

		/* register file */
		0xE3,
		{0x03, 0x01, 0x08, 0x00, 0x06},
		{0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0x0B, 0x3E,
		 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		 0xEA, 0x0C, 0xDF, 0x28, 0x00, 0xE7, 0x04, 0xE3,
		 0xFF},
		{0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x05, 0x0F,
		 0xFF},
		{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07,
		 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
		 0x01, 0x00, 0x0F, 0x00, 0x00},
		 
		/* palette */
		get_color_rgbi,
		set_color_rgbi,

		/* dimensions */
		0,
		640,
		480,
		4,

		/* functions */
		NULL,
		NULL,
		NULL,
		NULL
	},
	
	{ /* MODE_320x200x256 */

		/* register file */
		0x63,
		{0x03, 0x01, 0x0F, 0x00, 0x0E},
		{0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F,
		 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		 0x9C, 0x0E, 0x8F, 0x28, 0x40, 0x96, 0xB9, 0xA3,
		 0xFF},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
		 0xFF},
		{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
		 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		 0x41, 0x00, 0x0F, 0x00, 0x00},

		/* palette */
		get_color_true,
		set_color_true,

		/* dimensions */
		0,
		320,
		200,
		8,

		/* functions */
		vga_linear_plot,
		NULL,
		vga_linear_fill,
		NULL
	},

	{ /* MODE_320x240x256 */

		/* register file */
		0xE3,
		{0x03, 0x01, 0x0F, 0x00, 0x06},
		{0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0x0D, 0x3E,
		 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		 0xEA, 0xAC, 0xDF, 0x28, 0x00, 0xE7, 0x06, 0xE3,
		 0xFF},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
		 0xFF},
		{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
		 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		 0x41, 0x00, 0x0F, 0x00, 0x00},

		/* palette */
		get_color_true,
		set_color_true,

		/* dimensions */
		0,
		320,
		240,
		8,

		/* functions */
		vga_planar_plot,
		NULL,
		vga_planar_fill,
		NULL
	},

	{ /* MODE_320x240x64G */

		/* register file */
		0xE3,
		{0x03, 0x01, 0x0F, 0x00, 0x06},
		{0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0x0D, 0x3E,
		 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		 0xEA, 0xAC, 0xDF, 0x28, 0x00, 0xE7, 0x06, 0xE3,
		 0xFF},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
		 0xFF},
		{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
		 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		 0x41, 0x00, 0x0F, 0x00, 0x00},

		/* palette */
		get_color_gray,
		set_color_gray,

		/* dimensions */
		0,
		320,
		240,
		8,

		/* functions */
		vga_planar_plot,
		NULL,
		vga_planar_fill,
		NULL
	}

};

struct vga_mode *mode;

/****************************************************************************
 * vga_set_mode
 *
 * Changes the current VGA mode to the one at offset m in the driver's mode
 * vector (modev). Sets mode to point to the current mode structure.
 */

void vga_set_mode(int m) {
	size_t i;

	mode = &modev[m];

	/* write misc registers */
	outb(MISC_WRITE, mode->misc);

	/* write sequencer registers */
	for (i = 0; i < NUM_SEQ_REGS; i++) {
		outb(SEQ_INDEX, i);
		outb(SEQ_DATA, mode->seq[i]);
	}

	/* unlock CRTC registers */
	outb(CRTC_INDEX, 0x03);
	outb(CRTC_DATA, inb(CRTC_DATA) | 0x80);
	outb(CRTC_INDEX, 0x11);
	outb(CRTC_DATA, inb(CRTC_DATA) &~0x80);

	/* make sure CRTC remains unlocked */
	mode->crtc[0x03] |= 0x80;
	mode->crtc[0x11] &=~0x80;

	/* write CRTC registers */
	for (i = 0; i < NUM_CRTC_REGS; i++) {
		outb(CRTC_INDEX, i);
		outb(CRTC_DATA, mode->crtc[i]);
	}

	/* write graphics controller registers */
	for (i = 0; i < NUM_GC_REGS; i++) {
		outb(GC_INDEX, i);
		outb(GC_DATA, mode->gc[i]);
	}

	/* write attribute controller registers */
	for (i = 0; i < NUM_AC_REGS; i++) {
		inb(INSTAT_READ);
		outb(AC_INDEX, i);
		outb(AC_WRITE, mode->ac[i]);
	}

	/* unblank display */
	inb(INSTAT_READ);
	outb(AC_INDEX, 0x20);

	/* get framebuffer offset */
	outb(GC_INDEX, 0x06);
	switch ((inb(GC_DATA) >> 2) & 0x3) {
		case 0:
		case 1: mode->offset = 0x00000; break;
		case 2: mode->offset = 0x10000; break;
		case 3: mode->offset = 0x18000; break;
	}

	/* set palette */
	mode->set_color();
}
